(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{90:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return p})),n.d(t,"default",(function(){return s}));var r=n(3),a=n(7),i=(n(0),n(99)),o={id:"typescript",title:"Using TypeScript or Flow",sidebar_label:"TypeScript / Flow"},c={unversionedId:"typescript",id:"typescript",isDocsHomePage:!1,title:"Using TypeScript or Flow",description:"<div",source:"@site/docs/typescript.mdx",slug:"/typescript",permalink:"/immer/typescript",editUrl:"https://github.com/immerjs/immer/edit/master/website/docs/typescript.mdx",version:"current",sidebar_label:"TypeScript / Flow",sidebar:"Immer",previous:{title:"Async producers & createDraft / finishDraft",permalink:"/immer/async"},next:{title:"Immer performance",permalink:"/immer/performance"}},p=[{value:"Cast utilities",id:"cast-utilities",children:[]},{value:"Compatibility",id:"compatibility",children:[]}],l={toc:p};function s(e){var t=e.components,n=Object(a.a)(e,["components"]);return Object(i.b)("wrapper",Object(r.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(i.b)("center",null,Object(i.b)("div",{"data-ea-publisher":"immerjs","data-ea-type":"image",className:"horizontal bordered"}))," ",Object(i.b)("details",null,Object(i.b)("summary",{className:"egghead-summary"},"egghead.io lesson 12: Immer + TypeScript"),Object(i.b)("br",null),Object(i.b)("div",null,Object(i.b)("iframe",{width:"760",height:"427",scrolling:"no",src:"https://egghead.io/lessons/react-type-immutable-immer-data-with-typescript/embed"})),Object(i.b)("a",{className:"egghead-link",href:"https://egghead.io/lessons/react-type-immutable-immer-data-with-typescript"},"Hosted on egghead.io")),Object(i.b)("p",null,"The Immer package ships with type definitions inside the package, which should be picked up by TypeScript and Flow out of the box and without further configuration."),Object(i.b)("p",null,"The TypeScript typings automatically remove ",Object(i.b)("inlineCode",{parentName:"p"},"readonly")," modifiers from your draft types and return a value that matches your original type. See this practical example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import produce from "immer"\n\ninterface State {\n    readonly x: number\n}\n\n// `x` cannot be modified here\nconst state: State = {\n    x: 0\n}\n\nconst newState = produce(state, draft => {\n    // `x` can be modified here\n    draft.x++\n})\n\n// `newState.x` cannot be modified here\n')),Object(i.b)("p",null,"This ensures that the only place you can modify your state is in your produce callbacks. It even works recursively and with ",Object(i.b)("inlineCode",{parentName:"p"},"ReadonlyArray"),"!"),Object(i.b)("p",null,"For curried reducers, the type is inferred from the first argument of recipe function, so make sure to type it. The ",Object(i.b)("inlineCode",{parentName:"p"},"Draft")," utility type can be used if the state argument type is immutable:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-ts"},'import produce, {Draft} from "immer"\n\ninterface State {\n    readonly x: number\n}\n\n// `x` cannot be modified here\nconst state: State = {\n    x: 0\n}\n\nconst increment = produce((draft: Draft<State>, inc: number) => {\n    // `x` can be modified here\n    draft.x += inc\n})\n\nconst newState = increment(state, 2)\n// `newState.x` cannot be modified here\n')),Object(i.b)("p",null,Object(i.b)("em",{parentName:"p"},"Note: Since TypeScript support for recursive types is limited, and there is no co- contravariance, it might the easiest to not type your state as ",Object(i.b)("inlineCode",{parentName:"em"},"readonly")," (Immer will still protect against accidental mutations)")),Object(i.b)("h2",{id:"cast-utilities"},"Cast utilities"),Object(i.b)("p",null,"The types inside and outside a ",Object(i.b)("inlineCode",{parentName:"p"},"produce")," can be conceptually the same, but from a practical perspective different. For example, the ",Object(i.b)("inlineCode",{parentName:"p"},"State")," in the examples above should be considered immutable outside ",Object(i.b)("inlineCode",{parentName:"p"},"produce"),", but mutable inside ",Object(i.b)("inlineCode",{parentName:"p"},"produce"),"."),Object(i.b)("p",null,"Sometimes this leads to practical conflicts. Take the following example:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"type Todo = {readonly done: boolean}\n\ntype State = {\n    readonly finishedTodos: readonly Todo[]\n    readonly unfinishedTodos: readonly Todo[]\n}\n\nfunction markAllFinished(state: State) {\n    produce(state, draft => {\n        draft.finishedTodos = state.unfinishedTodos\n    })\n}\n")),Object(i.b)("p",null,"This will generate the error:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre"},"The type 'readonly Todo[]' is 'readonly' and cannot be assigned to the mutable type '{ done: boolean; }[]'\n")),Object(i.b)("p",null,"The reason for this error is that we assign our read only, immutable array to our draft, which expects a mutable type, with methods like ",Object(i.b)("inlineCode",{parentName:"p"},".push")," etc etc. As far as TS is concerned, those are not exposed from our original ",Object(i.b)("inlineCode",{parentName:"p"},"State"),". To hint TypeScript that we want to upcast the collection here to a mutable array for draft purposes, we can use the utility ",Object(i.b)("inlineCode",{parentName:"p"},"castDraft"),":"),Object(i.b)("p",null,Object(i.b)("inlineCode",{parentName:"p"},"draft.finishedTodos = castDraft(state.unfinishedTodos)")," will make the error disappear."),Object(i.b)("p",null,"There is also the utility ",Object(i.b)("inlineCode",{parentName:"p"},"castImmutable"),", in case you ever need to achieve the opposite. Note that these utilities are for all practical purposes no-ops, they will just return their original value."),Object(i.b)("p",null,"Tip: You can combine ",Object(i.b)("inlineCode",{parentName:"p"},"castImmutable")," with ",Object(i.b)("inlineCode",{parentName:"p"},"produce")," to type the return type of ",Object(i.b)("inlineCode",{parentName:"p"},"produce")," as something immutable, even when the original state was mutable:"),Object(i.b)("pre",null,Object(i.b)("code",{parentName:"pre",className:"language-typescript"},"// a mutable data structure\nconst baseState = {\n    todos: [{\n        done: false\n    }]\n}\n\nconst nextState = castImmutable(produce(baseState, _draft => {}))\n\n// inferred type of nextState is now:\n{\n    readonly todos: ReadonlyArray<{\n        readonly done: boolean\n    }>\n})\n")),Object(i.b)("h2",{id:"compatibility"},"Compatibility"),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," Immer v5.3+ supports TypeScript v3.7+ only."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," Immer v3.0+ supports TypeScript v3.4+ only."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," Immer v1.9+ supports TypeScript v3.1+ only."),Object(i.b)("p",null,Object(i.b)("strong",{parentName:"p"},"Note:")," Flow support might be removed in future versions and we recommend TypeScript"))}s.isMDXComponent=!0},99:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return m}));var r=n(0),a=n.n(r);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function p(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=a.a.createContext({}),s=function(e){var t=a.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=s(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},u=a.a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,l=p(e,["components","mdxType","originalType","parentName"]),b=s(n),u=r,m=b["".concat(o,".").concat(u)]||b[u]||d[u]||i;return n?a.a.createElement(m,c(c({ref:t},l),{},{components:n})):a.a.createElement(m,c({ref:t},l))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var c={};for(var p in t)hasOwnProperty.call(t,p)&&(c[p]=t[p]);c.originalType=e,c.mdxType="string"==typeof e?e:r,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return a.a.createElement.apply(null,o)}return a.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"}}]);